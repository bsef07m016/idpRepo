// Generated by CoffeeScript 1.4.0
(function() {

  define(function() {
    return {
      init: function(chart) {
        var _base, _base1;
        this.chart = chart;
        this.options = this.chart.options["scale"];
        this.setupXScale();
        this.setupYScale();
        this.setupDomain(this.chart.xScale, "x");
        this.setupDomain(this.chart.yScale, "y");
        if (typeof (_base = this.chart.xScale).nice === "function") {
          _base.nice();
        }
        return typeof (_base1 = this.chart.yScale).nice === "function" ? _base1.nice() : void 0;
      },
      setupXScale: function() {
        if (!(this.options && this.options["x"] && this.options["x"]["type"])) {
          this.setupXScaleLinear();
          return;
        }
        switch (this.options["x"]["type"]) {
          case "linear":
            return this.setupXScaleLinear();
          case "ordinal":
            return this.setupXScaleOrdinal();
          case "date":
            return this.setupXScaleDate();
        }
      },
      setupYScale: function() {
        return this.setupYScaleLinear();
      },
      setupXScaleLinear: function() {
        return this.chart.xScale = d3.scale.linear().range([0, this.chart.options.width]);
      },
      setupXScaleOrdinal: function() {
        var padding, _base, _ref, _ref1;
        if ((_ref = (_base = this.options["x"])["domain"]) == null) {
          _base["domain"] = {
            type: "map"
          };
        }
        padding = (_ref1 = this.options.x.padding) != null ? _ref1 : 0.1;
        return this.chart.xScale = d3.scale.ordinal().rangeRoundBands([0, this.chart.options.width], padding);
      },
      setupXScaleDate: function() {
        return this.chart.xScale = d3.time.scale().range([0, this.chart.options.width]);
      },
      setupYScaleLinear: function() {
        return this.chart.yScale = d3.scale.linear().range([this.chart.options.height, 0]);
      },
      setupDomain: function(scale, key) {
        var s, strategy, _i, _len, _results;
        if (!((this.options != null) && (this.options[key] != null) && (this.options[key]["domain"] != null) && this.options[key]["domain"])) {
          this.setupDomainExtent(scale, key);
          return;
        }
        strategy = this.options[key]["domain"]["type"];
        if (strategy instanceof Array) {
          _results = [];
          for (_i = 0, _len = strategy.length; _i < _len; _i++) {
            s = strategy[_i];
            _results.push(this.applyStrategy(s, scale, key));
          }
          return _results;
        } else {
          return this.applyStrategy(strategy, scale, key);
        }
      },
      applyStrategy: function(strategy, scale, key) {
        switch (strategy) {
          case "extent":
            return this.setupDomainExtent(scale, key);
          case "map":
            return this.setupDomainMap(scale, key);
          case "stretch":
            return this.setupDomainStretch(scale);
          case "fixed":
            return this.setupDomainFixed(scale, key);
          default:
            throw new Error("Not a valid scale type: " + strategy);
        }
      },
      setupDomainExtent: function(scale, key) {
        return scale.domain(d3.extent(this.allValues(key)));
      },
      setupDomainStretch: function(scale, minStretch, maxStretch) {
        var domain;
        if (minStretch == null) {
          minStretch = 0.9;
        }
        if (maxStretch == null) {
          maxStretch = 1.1;
        }
        domain = scale.domain();
        return scale.domain([domain[0] * minStretch, domain[1] * maxStretch]);
      },
      setupDomainMap: function(scale, key) {
        return scale.domain(this.allValues(key));
      },
      setupDomainFixed: function(scale, key) {
        var high, low;
        low = this.getBound(this.options[key]["domain"]["low"], key);
        high = this.getBound(this.options[key]["domain"]["high"], key);
        return scale.domain([low, high]);
      },
      allValues: function(key) {
        var allValues, dataPoint, lineData, _i, _j, _len, _len1, _ref;
        allValues = [];
        _ref = this.chart.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          lineData = _ref[_i];
          for (_j = 0, _len1 = lineData.length; _j < _len1; _j++) {
            dataPoint = lineData[_j];
            allValues.push(dataPoint[key]);
          }
        }
        return allValues;
      },
      getBound: function(bound, key) {
        if ($.isNumeric(bound)) {
          return bound;
        }
        switch (bound) {
          case "min":
            return d3.min(this.chart.data, function(d) {
              return d[key];
            });
          case "max":
            return d3.max(this.chart.data, function(d) {
              return d[key];
            });
          default:
            throw new Error("Not a valid bound: " + bound);
        }
      }
    };
  });

}).call(this);
